{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting started","text":"<p>This package allows to create <code>tar</code> files and compress any file via <code>gzip</code> all in memory. This means that you don't have to have the source files written to disk to compress them.</p> <p>This package also work lazily, meaning that you never have to load a whole file in memory allowing you to work with files that may not fit in memory.</p> <p>Combining this package with the rest of the Innmind ecosystem unlocks opportunities that weren't possible previously (or at least very hard to achieve).</p> <p>All use cases use the <code>innmind/operating-system</code> package.</p>"},{"location":"use-cases/backup/","title":"Creating a backup from different sources","text":"<pre><code>use Innmind\\OperatingSystem\\Factory;\nuse Formal\\AccessLayer\\Query\\SQL;\nuse Innmind\\Filesystem\\{\n    Name,\n    File\\,\n    File\\Content\\Line,\n    Directory,\n};\nuse Innmind\\MediaType\\MediaType;\nuse Innmind\\Url\\{\n    Url,\n    Path,\n};\nuse Innmind\\Immutable\\Str;\nuse Innmind\\Encoding\\{\n    Gzip,\n    Tar,\n};\n\n$os = Factory::build();\n\n$data = $os\n    -&gt;filesystem()\n    -&gt;mount(Path::of('path/to/stored/data'))\n    -&gt;root()\n    -&gt;rename(Name::of('data'));\n$sql = $os-&gt;remote()-&gt;sql(Url::of('mysql://{user}:{password}@localhost:3306/{database}'));\n$users = $sql(SQL::onDemand('SELECT * FROM users'))\n    -&gt;map(static fn($row) =&gt; \\implode(\n        \"\\t\",\n        \\array_values($row-&gt;toArray()),\n    ))\n    -&gt;map(Str::of(...))\n    -&gt;map(Line::of(...));\n\n$archive = Gzip::compress()(\n    Tar::encode($os-&gt;clock())(\n        Directory::named('archive')\n            -&gt;add($data)\n            -&gt;add(File::named(\n                'users.tsv',\n                $users,\n                MediaType::of('text/tab-separated-values'),\n            )),\n    ),\n);\n</code></pre> <p>Up to this point <code>$archive</code> represents a file content but no real operation has been done. For the real compression to happen you need to unwrap the file either by persisting to the filesystem, sending it through HTTP/AMQP or returning it as an HTTP response. Here's an example of a simple file responding to an HTTP request:</p> <pre><code>use Innmind\\Http\\{\n    ResponseSender,\n    Response,\n    Response\\StatusCode,\n    ProtocolVersion,\n    Headers,\n    Header\\ContentType,\n};\n\n$archive = /* see above */;\n\n(new ResponseSender($os-&gt;clock()))(Response::of(\n    StatusCode::ok,\n    ProtocolVersion::v11,\n    Headers::of(\n        ContentType::of('application', 'octet-stream')\n    ),\n    $archive,\n));\n</code></pre> <p>And that's it ! <code>ResponseSender</code> will stream the archive chunk by chunk.</p>"},{"location":"use-cases/compressed-at-rest/","title":"Storing compressed files","text":"<p>In many applications we allow our users to upload files. Storing them can take up a lot of space.</p> <p>Instead of storing these files as is, we could store them gzipped to save space and return them gzipped or uncompressed depending of the supported features.</p> <p>Here's an example:</p> <pre><code>use Innmind\\OperatingSystem\\Factory;\nuse Innmind\\Http\\Factory\\ServerRequest\\ServerRequestFactory;\nuse Innmind\\Filesystem\\Name;\nuse Innmind\\Encoding\\Gzip;\nuse Innmind\\Url\\Path;\nuse Innmind\\Http\\{\n    Response,\n    Response\\StatusCode,\n    ResponseSender,\n};\n\n$os = Factory::build();\n$serverRequest = ServerRequestFactory::default($os-&gt;clock())();\n\n$response = $serverRequest\n    -&gt;files()\n    -&gt;under('tsv')\n    -&gt;get('users')\n    -&gt;map(static fn($file) =&gt; $file-&gt;content()\n    -&gt;map(Gzip::compress())\n    -&gt;map(static fn($content) =&gt; File::named('users.tsv.gz', $content))\n    -&gt;map(\n        static fn($file) =&gt; $os\n            -&gt;filesystem()\n            -&gt;mount(Path::of('path/to/stored/data/'))\n            -&gt;add($file)),\n    )\n    -&gt;match(\n        static fn() =&gt; Response::of(\n            StatusCode::created,\n            $serverRequest-&gt;protocolVersion(),\n        ),\n        static fn() =&gt; Response::of(\n            StatusCode::badRequest,\n            $serverRequest-&gt;protocolVersion(),\n        ),\n    );\n\n(new ResponseSender($os-&gt;clock()))($response);\n</code></pre> <p>This code will take any file uploaded in the key <code>tsv[users]</code>, gzip it and write it in the <code>path/to/stored/data/</code> directory under the name <code>users.tsv.gz</code> and return a <code>201</code> HTTP response. If the upload failed it will return a <code>400</code> response.</p> <p>And for the code streaming this file:</p> <pre><code>use Innmind\\OperatingSystem\\Factory;\nuse Innmind\\Http\\Factory\\ServerRequest\\ServerRequestFactory;\nuse Innmind\\Filesystem\\Name;\nuse Innmind\\Encoding\\Gzip;\nuse Innmind\\Url\\Path;\nuse Innmind\\Http\\{\n    Response,\n    Response\\StatusCode,\n    ResponseSender,\n    Headers,\n    Header\\ContentType,\n    Header\\ContentEncoding,\n};\n\n$os = Factory::build();\n$serverRequest = ServerRequestFactory::default($os-&gt;clock())();\n\n$acceptGzip = $serverRequest\n    -&gt;headers()\n    -&gt;get('accept-encoding')\n    -&gt;map(static fn($header): bool =&gt; $header-&gt;values()-&gt;any(\n        static fn($value) =&gt; $value-&gt;toString() === 'gzip',\n    ))\n    -&gt;match(\n        static fn(bool $accept): bool =&gt; $accept,\n        static fn() =&gt; false,\n    );\n\n$response = $os\n    -&gt;filesystem()\n    -&gt;mount(Path::of('path/to/stored/data/'))\n    -&gt;get(Name::of('users.tsv.gz'))\n    -&gt;map(static fn($file) =&gt; match ($acceptGzip) {\n        true =&gt; Response::of(\n            StatusCode::ok,\n            $serverRequest-&gt;protocolVersion(),\n            Headers::of(\n                ContentEncoding::of('gzip'),\n                ContentType::of('text', 'tab-separated-values'),\n            ),\n            $file-&gt;content(),\n        ),\n        false =&gt; Response::of(\n            StatusCode::ok,\n            $serverRequest-&gt;protocolVersion(),\n            Headers::of(\n                ContentType::of('text', 'tab-separated-values'),\n            ),\n            Gzip::decompress()($file-&gt;content()),\n        ),\n    })\n    -&gt;match(\n        static fn($response) =&gt; $response,\n        static fn() =&gt; Response::of(\n            StatusCode::notFound,\n            $serverRequest-&gt;protocolVersion(),\n        ),\n    );\n\n(new ResponseSender($os-&gt;clock()))($response);\n</code></pre> <p>Here we try to load the <code>users.tsv.gz</code> file, we check if the caller accepts a gzipped content, if so we return the file as is via a <code>200</code> HTTP response and if not we decompress the file and return it. And if the file doesn't exist we return a <code>400</code> response.</p>"},{"location":"use-cases/http/","title":"Sending compressed files through HTTP","text":"<pre><code>use Innmind\\OperatingSystem\\Factory;\nuse Innmind\\Filesystem\\Name;\nuse Innmind\\Encoding\\Gzip;\nuse Innmind\\Http\\{\n    Request,\n    Method,\n    ProtocolVersion,\n    Headers,\n    Header\\ContentEncoding,\n};\nuse Innmind\\Url\\{\n    Url,\n    Path,\n};\n\n$os = Factory::build();\n$http = $os-&gt;remote()-&gt;http();\n$os\n    -&gt;filesystem()\n    -&gt;mount(Path::of('path/to/stored/data/'))\n    -&gt;get(Name::of('somefile.txt'))\n    -&gt;map(static fn($file) =&gt; $file-&gt;content());\n    -&gt;map(Gzip::compress())\n    -&gt;match(\n        static fn($content) =&gt; $http(Request::of(\n            Url::of('https://some-app.tld/upload'),\n            Method::post,\n            ProtocolVersion::v11,\n            Headers::of(\n                ContentEncoding::of('gzip'),\n            ),\n            $content,\n        )),\n        static fn() =&gt; null,\n    );\n</code></pre> <p>If <code>somefile.txt</code> exists then it is gzipped and then sent to <code>https://some-app.tld/upload</code>. If the file doesn't exist then nothing is done.</p>"}]}